channel hour_w_first, hour_r_first, hour_w_second, hour_r_second : { -1..20}
channel clock_w : {131067 ..131077}
channel clock

Seven_segment_clock(i) =
    (i+1 <= 131077) & (
        clock_w ! i+1 -> Seven_segment_clock(i+1) [] SKIP)

Hours =
    (clock -> clock_w ? hours_in ->
        if (hours_in == 131067)
        then clock -> hour_r_first ! -1 -> hour_r_second ! -1 -> Hours
        else (
            let
                hours = hours_in % 60 -- For testing
                -- hours = ( hours_in / 3600 ) % 24
                hours_first_temp = hours / 10
                hours_second_temp = hours % 10
            within
                clock ->
                -- I might be able to put them together in a if x > 10 or y >10
                -- But this would probably not be possible to auto generate.
                (hours_first_temp <= 100) & (
                    hour_r_first ! hours_first_temp ->
                    (hours_second_temp <= 100) & (
                        hour_r_second ! hours_second_temp ->
                        Hours
                    )
                )
        )
    ) [] SKIP


-- First digit buffers
Read_first = clock -> ((hour_r_first ? x -> (hour_r_first ? x -> STOP [] Write_first(x))
                    [] clock -> Read_first) [] SKIP)

Writes_first(x) = hour_w_first ! x -> (Writes_first(x) [] Read_first)
Write_first(x) = clock -> (Writes_first(x) [] Read_first) [] SKIP

-- Second digit buffers
Read_second = clock -> ((hour_r_second ? x -> (hour_r_second ? x -> STOP [] Write_second(x))
                    [] clock -> Read_second) [] SKIP)

Writes_second(x) = hour_w_second ! x -> (Writes_second(x) [] Read_second)
Write_second(x) = clock -> (Writes_second(x) [] Read_second) [] SKIP


hours_hours_out_first_digit_monitor(c) =
    (c ? x ->
    (0 <= x and x <= 5 or x == -1) & (
        hours_hours_out_first_digit_monitor(c))
    ) [] SKIP

hours_hours_out_second_digit_monitor(c) =
    (c ? x ->
    (0 <= x and x <= 9 or x == -1) & (
        hours_hours_out_second_digit_monitor(c))
    ) [] SKIP



Clock(10) = SKIP
Clock(n) =  clock -> clock -> Clock(n+1)

Network =
        (
            (
                (
                    (
                        (
                        Hours
                        [|{| hour_r_first |}|]
                        hours_hours_out_first_digit_monitor(hour_r_first)
                        )
                    [|{| hour_r_second |}|]
                    hours_hours_out_second_digit_monitor(hour_r_second)
                    )
                [{| clock, clock_w, hour_r_first, hour_r_second|} || {| clock_w |}]
                Seven_segment_clock(131067)
                )
            [{| clock, clock_w, hour_r_first, hour_r_second|} || {| clock, hour_r_first, hour_w_first |}]
            Write_first(-1)
            )
        [{| clock, clock_w, hour_r_first, hour_r_second, hour_w_first|} || {| clock, hour_r_second, hour_w_second |}]
        Write_second(-1)
        )
        [|{| clock |}|] (
        Clock(1)
        )

assert SKIP [F= Network \ Events
-- assert Network :[deadlock free [F]]







