channel hour_r_first : { -1..3}
channel hour_r_second : { -1..15}
channel minutes_r_first : { -1..7}
channel minutes_r_second : { -1..15}
channel seconds_r_first : { -1..7}
channel seconds_r_second : { -1..15}
channel clock_w : { -1 ..50}
channel sync

Clock(1) = SKIP
Clock(n) =  sync -> sync -> Clock(n+1)

Hours =
    (sync -> clock_w ? hours_in -> sync ->
        if (hours_in == -1) -- I have to figure out how to do this! It might work with -1 for the experiments because we go from 0-x
        then hour_r_first ! -1 -> hour_r_second ! -1 -> Hours
        else (
            let
                hours = ( hours_in / 3600 ) % 24
                hours_first_temp = hours / 10
                hours_second_temp = hours % 10
            within
                -- I might be able to put them together in a if x > 10 or y >10
                -- But this would probably not be possible to auto generate.
                (hours_first_temp <= 3) &
                    (hour_r_first ! hours_first_temp ->
                    (hours_second_temp <= 15) &
                        (hour_r_second ! hours_second_temp ->
                        Hours
                        )
                    )
            )
    ) [] SKIP

hours_hours_out_first_digit_monitor(c) =
    (c ? x ->
    (0 <= x and x <= 2 or x == -1) &
        hours_hours_out_first_digit_monitor(c)
    ) [] SKIP

hours_hours_out_second_digit_monitor(c) =
    (c ? x ->
    (0 <= x and x <= 9 or x == -1) &
        hours_hours_out_second_digit_monitor(c)
    ) [] SKIP


Hours_Network =
        (
            (
            Hours
            [|{| hour_r_first |}|]
            hours_hours_out_first_digit_monitor(hour_r_first)
            )
        [|{| hour_r_second |}|]
        hours_hours_out_second_digit_monitor(hour_r_second)
        )
        [|{| sync |}|]
        (
        Clock(0)
        )

assert SKIP [F= Hours_Network \ Events
-- assert Hours_Network :[deadlock free [F]]
--------------------------------------------------------------------------

Minutes =
    (sync -> clock_w ? min_in -> sync ->
        if (min_in == -1) -- I have to figure out how to do this! It might work with -1 for the experiments because we go from 0-x
        then minutes_r_first ! -1 -> minutes_r_second ! -1 -> Hours
        else (
            let
                min = ( min_in / 60 ) % 60
                min_first_temp = min / 10
                min_second_temp = min % 10
            within
                -- I might be able to put them together in a if x > 10 or y >10
                -- But this would probably not be possible to auto generate.
                (min_first_temp <= 7) &
                    (minutes_r_first ! min_first_temp ->
                    (min_second_temp <= 15) &
                        (minutes_r_second ! min_second_temp ->
                        Minutes
                        )
                    )
            )
    ) [] SKIP

minutes_min_out_first_digit_monitor(c) =
    (c ? x ->
    (0 <= x and x <= 5 or x == -1) &
        minutes_min_out_first_digit_monitor(c)
    ) [] SKIP

minutes_min_out_second_digit_monitor(c) =
    (c ? x ->
    (0 <= x and x <= 9 or x == -1) &
        minutes_min_out_second_digit_monitor(c)
    ) [] SKIP

Minutes_Network =
        (
            (
            Minutes
            [|{| minutes_r_first |}|]
            minutes_min_out_first_digit_monitor(minutes_r_first)
            )
        [|{| minutes_r_second |}|]
        minutes_min_out_second_digit_monitor(minutes_r_second)
        )
        [|{| sync |}|]
        (
        Clock(0)
        )

assert SKIP [F= Minutes_Network \ Events


--------------------------------------------------------------------------


Seconds =
    (sync -> clock_w ? sec_in -> sync ->
        if (sec_in == -1) -- I have to figure out how to do this! It might work with -1 for the experiments because we go from 0-x
        then seconds_r_first ! -1 -> seconds_r_second ! -1 -> Seconds
        else (
            let
                sec = sec_in % 60
                sec_first_temp = sec / 10
                sec_second_temp = sec % 10
            within
                -- I might be able to put them together in a if x > 10 or y >10
                -- But this would probably not be possible to auto generate.
                (sec_first_temp <= 7) &
                    (seconds_r_first ! sec_first_temp ->
                    (sec_second_temp <= 15) &
                        (seconds_r_second ! sec_second_temp ->
                        Seconds
                        )
                    )
            )
    ) [] SKIP


sec_sec_out_first_digit_monitor(c) =
    (c ? x ->
    (0 <= x and x <= 5 or x == -1) &
        sec_sec_out_first_digit_monitor(c)
    ) [] SKIP

sec_sec_out_second_digit_monitor(c) =
    (c ? x ->
    (0 <= x and x <= 9 or x == -1) &
        sec_sec_out_second_digit_monitor(c)
    ) [] SKIP

Seconds_Network =
        (
            (
            Seconds
            [|{| seconds_r_first |}|]
            sec_sec_out_first_digit_monitor(seconds_r_first)
            )
        [|{| seconds_r_second |}|]
        sec_sec_out_second_digit_monitor(seconds_r_second)
        )
        [|{| sync |}|]
        (
        Clock(0)
        )

assert SKIP [F= Seconds_Network \ Events


