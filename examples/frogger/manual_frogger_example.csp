channel src_out : {0..10}
channel frogger1_output : {0..100}
channel frogger2_output : {0..100}

Src() =
    let
        i = i + 1
    within
        src_out ! i ->
        SKIP


Frogger1(input_variable) =
    let
        results = input_variable + 1
    within
        frogger1_output ! results -> SKIP

Frogger2(input_variable) =
    let
        results = input_variable + 2
    within
        frogger2_output ! results -> SKIP


-- De to frogger processer kører parallelt uden at syncronisere og derefter
-- syncronisere de på monitor processen der modtager begge input og laver en
-- udregning ud fra dette som bliver verificeret. Det er ikke sikkert det kan
-- genereres sådan, men det er ihvertfald sådan det kan virke.

Frog_network =
    src_out ? variable ->
    (Frogger1(variable)
    |||
    Frogger2(variable))


Network = Frog_network
    [| {| frogger2_output, frogger1_output |}|]
    Frogger_monitor(frogger1_output, frogger2_output)

assert SKIP [F= Network \ Events

Frogger_monitor(c1, c2) =
        c1 ? x -> c2 ? y ->
        if 0 <= x+y and x+y <= 22
        then SKIP else STOP